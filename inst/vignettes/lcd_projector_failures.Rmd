---
title: "lcd_projector_failures"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{lcd_projector_failures}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(foocafeReliability)
library(rstan)
```


## Build model  (based on example 4.3 from Bayesian Reliability)
```{R}

modelString <- "
  data {
    int <lower=0> Nobs;
    real <lower=0> projection_hours[Nobs];
  }

  parameters {
    real <lower=0> lambda;
  }
  
  transformed parameters {
    real MTTF;
    
    MTTF = 1 / lambda;
  }

  model {
    projection_hours ~ exponential(lambda);

    lambda ~ gamma(2.5, 2350);
  }
"

lcd_exponential_model <- rstan::stan_model(model_code = modelString)


```

## Fit model to data
```{R}

lcd_fail_list <- list(Nobs = NROW(lcd_projector_failures$projection_hours),
                          projection_hours = lcd_projector_failures$projection_hours
                          )

lcd_exponential_output <- rstan::sampling(lcd_exponential_model, data = lcd_fail_list, chains = 4, iter = 4000, control = list(adapt_delta = 0.9))

```


```{R}

stan_hist(output, c("lambda", "lambda_prior", "MTTF"))

```


```{R}

output_vals <- extract(output)

data <- data.frame(output_vals["lambda"],
                   output_vals["lambda_prior"],
                   output_vals["MTTF"])

ggplot(data = data) +
  geom_density(aes(lambda)) +
  geom_density(aes(lambda_prior), linetype = "dashed")

ggplot(data = data) +
  geom_density(aes(MTTF))


```


```{R}

t = seq(1,3500,100)
lambda_vals <- output_vals[["lambda"]]

reliability <- data.frame(matrix(0,
                          nrow = NROW(t),
                          ncol = NROW(lambda_vals)))

for (ii in 1:NROW(reliability)) {
  print(ii)
  reliability[ii,] = exp(-lambda_vals * t[ii])
}

ggplot(data = reliability) +
  geom_density(aes(lambda)) +
  geom_density(aes(lambda_prior), linetype = "dashed")


```


```{R}

costTableList <- list()

for (ii in 1:NROW(output_vals$lambda)){

  thisLambda <- output_vals$lambda[ii]
  
  get_reliability <- function(thisLambda){
    f1 <- function(t){
      exp(-thisLambda * t)
    }
    return(f1)
  }

  reliability <- get_reliability(thisLambda)

  costTable <- data.frame("t" = t,
                          "reliability" = numeric(NROW(t)))

  costTable$reliability <- reliability(t)
  
  costTableList[[ii]] <- costTable
}

temp <- lapply(costTableList, '[', 2) %>% dplyr::bind_cols()

data <- data.frame(t = t,
                   meanVal = apply(temp, 1, mean),
                   LQ = apply(temp, 1, function(x) {quantile(x, 0.1)}),
                   UQ = apply(temp, 1, function(x) {quantile(x, 0.90)}))


ggplot(data = data, aes(t)) +
  geom_line(aes(y = meanVal)) +
  geom_ribbon(aes(ymin = LQ, ymax = UQ), alpha = 0.05)
  

```



## Evaluate goodness of fit
```{R}

n <- NROW(lcd_projector_failures)
K <- round(n^0.4)
a <- seq(0,1,1/K)
p <- diff(a)
m <- numeric(K)
output_vals <- rstan::extract(lcd_exponential_output)

chi_val <- qchisq(0.95,K-1)
r_b <- numeric(NROW(output_vals$lambda))

for (jj in 1:NROW(r_b)) {
  
  thisLambda <- output_vals$lambda[jj]
  
  probabilities <- pexp(lcd_projector_failures$projection_hours, thisLambda)
  
  for (ii in 1:length(m)){
    m[ii] <- sum(probabilities > a[ii] & probabilities < a[ii+1])
  }
  
  r_b[jj] <- sum(((m - n*p)^2)/(n*p))

}

```


```{R}

sum(r_b > chi_val)/NROW(r_b) * 100

```



### Weibull fit:

## Build model
```{R}

modelString <- "
  data {
    int<lower=0> Nobs;
    vector<lower=0>[Nobs] projection_hours;
  }

  parameters {
    real<lower=0> shape;
    real<lower=0> scale;
    
  }

  model {
    target += weibull_lpdf(projection_hours | shape, scale);

    shape ~ gamma(1, 1);
    scale ~ gamma(2.5, 0.006);
  }
"

lcd_weibull_model <- rstan::stan_model(model_code = modelString)

lcd_fail_list <- list(Nobs = NROW(lcd_projector_failures$projection_hours),
                          projection_hours = lcd_projector_failures$projection_hours
                          )

lcd_weibull_output <- rstan::sampling(lcd_weibull_model, data = lcd_fail_list, chains = 4, iter = 4000, control = list(adapt_delta = 0.9))

```

## Evaluate goodness of fit
```{R}

n <- NROW(lcd_projector_failures)
K <- round(n^0.4)
a <- seq(0,1,1/K)
p <- diff(a)
m <- numeric(K)
output_vals <- rstan::extract(lcd_weibull_output)

chi_val <- qchisq(0.95,K-1)
r_b <- numeric(NROW(output_vals$shape))

for (jj in 1:NROW(r_b)) {
  
  thisShape <- output_vals$shape[jj]
  thisScale <- output_vals$scale[jj]
  
  probabilities <- pweibull(lcd_projector_failures$projection_hours, thisShape, thisScale)
  
  for (ii in 1:length(m)){
    m[ii] <- sum(probabilities > a[ii] & probabilities < a[ii+1])
  }
  
  r_b[jj] <- sum(((m - n*p)^2)/(n*p))

}

(sum(r_b > chi_val)/NROW(r_b) * 100)

```


### lognormal fit:

## Build model
```{R}

modelString <- "
  data {
    int<lower=0> Nobs;
    vector<lower=0>[Nobs] projection_hours;
  }

  parameters {
    real mu;
    real sigma_2;
  }
  
  transformed parameters {
    real<lower=0> sigma;
    
    sigma = sqrt(sigma_2);
  }

  model {
    
    target += lognormal_lpdf(projection_hours | mu, sigma);

    mu ~ normal(6, 5);
    sigma_2 ~ inv_gamma(6.5, 23.5);
  }
"

lcd_lognormal_model <- rstan::stan_model(model_code = modelString)

lcd_fail_list <- list(Nobs = NROW(lcd_projector_failures$projection_hours),
                          projection_hours = lcd_projector_failures$projection_hours
                          )

lcd_lognormal_output <- rstan::sampling(lcd_lognormal_model, data = lcd_fail_list, chains = 4, iter = 4000, control = list(adapt_delta = 0.9))

```


## Evaluate goodness of fit
```{R}

n <- NROW(lcd_projector_failures)
K <- round(n^0.4)
a <- seq(0,1,1/K)
p <- diff(a)
m <- numeric(K)
output_vals <- rstan::extract(lcd_lognormal_output)

chi_val <- qchisq(0.95,K-1)
r_b <- numeric(NROW(output_vals$mu))

for (jj in 1:NROW(r_b)) {
  
  thisMu <- output_vals$mu[jj]
  thisSigma <- output_vals$sigma[jj]
  
  probabilities <- plnorm(lcd_projector_failures$projection_hours, thisMu, thisSigma)
  
  for (ii in 1:length(m)){
    m[ii] <- sum(probabilities > a[ii] & probabilities < a[ii+1])
  }
  
  r_b[jj] <- sum(((m - n*p)^2)/(n*p))

}

(sum(r_b > chi_val)/NROW(r_b) * 100)

```
